#!/usr/bin/env bash
# Progressive streaming copy with robust mount/device detection and resume-on-remount.
# - Resolves the mount source for given paths (works for files or directories)
# - Prints the underlying device chain (mapper -> partition -> disk) using lsblk/cryptsetup/dmsetup
# - Waits for manual remounts (source or destination) and automatically resumes
# - Supports a --probe mode to show mount/device mapping without copying

set -euo pipefail
IFS=$'
	'

DEFAULT_CHUNK_MB=25
MIN_CHUNK_MB=1
MAX_CHUNK_MB=100
CYCLE_REST=3
VERIFY_CHECKSUMS=true

usage() {
    cat <<EOF
Usage: $0 [--probe] [SOURCE] [DEST]

If SOURCE and DEST are omitted the script will run interactively.
--probe   : show mount source and physical device chain for SOURCE and DEST, then exit

Examples:
  $0 /run/media/user/USB/label/W /run/media/user/SSD/label
  $0 --probe /run/media/user/USB/label/W /run/media/user/SSD/label

EOF
}

# Resolve mount source (device) and mountpoint for a given path.
# This climbs up the directory tree until a mount is found.
find_mount_source_and_point() {
    local p="$1"
    while true; do
        # if path doesn't exist, try parent (for removed mounts, keep trying)
        if [ -e "$p" ] || [ "$p" = "/" ]; then
            local src
            src=$(findmnt -n -o SOURCE --target "$p" 2>/dev/null || true)
            local mnt
            mnt=$(findmnt -n -o TARGET --target "$p" 2>/dev/null || true)
            if [ -n "$src" ]; then
                echo "$src|$mnt"
                return 0
            fi
        fi
        if [ "$p" = "/" ]; then
            # not mounted
            echo "|"
            return 1
        fi
        p=$(dirname "$p")
    done
}

# Resolve a device to a chain of underlying devices (mapper -> partition -> disk)
get_device_chain() {
    local dev="$1"
    # If empty
    if [ -z "$dev" ]; then
        echo "(none)"
        return
    fi

    # Normalize to full /dev path
    case "$dev" in
        UUID=*|LABEL=*|/dev/disk/by-* )
            # findmnt usually resolves these but handle if seen
            resolved=$(readlink -f "$dev" 2>/dev/null || true)
            [ -n "$resolved" ] && dev="$resolved"
            ;;
    esac

    local chain="$dev"
    local curr="$dev"
    # iterate a few times to avoid infinite loops
    for i in 1 2 3 4; do
        # try lsblk PKNAME
        if command -v lsblk >/dev/null 2>&1; then
            parent=$(lsblk -n -o PKNAME "$curr" 2>/dev/null || true)
            if [ -n "$parent" ]; then
                parent_dev="/dev/$parent"
                chain="$chain -> $parent_dev"
                curr="$parent_dev"
                continue
            fi
        fi

        # try cryptsetup status for /dev/mapper devices
        if command -v cryptsetup >/dev/null 2>&1 && echo "$curr" | grep -q '/dev/mapper/'; then
            name=$(basename "$curr")
            underlying=$(cryptsetup status "$name" 2>/dev/null | awk -F": " '/device:/{print $2}' || true)
            if [ -n "$underlying" ]; then
                chain="$chain -> $underlying"
                curr="$underlying"
                continue
            fi
        fi

        # try dmsetup deps (may need basename)
        if command -v dmsetup >/dev/null 2>&1; then
            name=$(basename "$curr")
            deps=$(dmsetup deps "$name" 2>/dev/null | awk -F":" '{print $2}' || true)
            if [ -n "$deps" ]; then
                # pick the first dependency token that looks like /dev/...
                dep_dev=$(echo "$deps" | awk '{for(i=1;i<=NF;i++){if($i ~ /\//) {print $i; exit}}}')
                if [ -n "$dep_dev" ]; then
                    chain="$chain -> $dep_dev"
                    curr="$dep_dev"
                    continue
                fi
            fi
        fi

        # try to find parent via /sys/block (for partitions like sda1 -> sda)
        if [ -b "$curr" ]; then
            # get basename and test /sys/block/*
            name=$(basename "$curr")
            # For partitions, parent may be in /sys/class/block/<name>/..../
            if [ -e "/sys/class/block/$name/.." ]; then
                # try to read the 'partition' attribute or find parent
                parent_dir=$(readlink -f "/sys/class/block/$name/.." 2>/dev/null || true)
                # Look for nearest block device parent in the path
                if [ -n "$parent_dir" ]; then
                    # search for a directory in the path that is a block device and not same name
                    p="${parent_dir}"
                    while [ "$p" != "/" ]; do
                        cand=$(basename "$p")
                        if [ -b "/dev/$cand" ] && [ "$cand" != "$name" ]; then
                            chain="$chain -> /dev/$cand"
                            curr="/dev/$cand"
                            break
                        fi
                        p=$(dirname "$p")
                    done
                    if [ "$curr" != "$dev" ] && [ "$curr" != "/dev/$name" ]; then
                        continue
                    fi
                fi
            fi
        fi

        # nothing more to resolve
        break
    done

    echo "$chain"
}

# Check whether a given path's mount is present and accessible
check_mount_accessible() {
    local path="$1"
    local mp_info
    mp_info=$(find_mount_source_and_point "$path" 2>/dev/null || true)
    if [ -z "$mp_info" ] || [ "$mp_info" = "|" ]; then
        return 1
    fi
    local src=${mp_info%%|*}
    local mnt=${mp_info##*|}
    # ensure mountpoint is accessible
    if [ -z "$mnt" ] || [ ! -d "$mnt" ]; then
        return 1
    fi
    # ensure we can list the mountpoint
    if ! ls "$mnt" >/dev/null 2>&1; then
        return 1
    fi
    # ensure device node exists (blocks or mapper nodes)
    if [ -n "$src" ]; then
        if [ -b "$src" ] || [ -e "$src" ]; then
            return 0
        else
            return 1
        fi
    fi
    return 1
}

# Wait for mount (manual remount by user)
wait_for_mount() {
    local path="$1"
    local which="$2"
    echo "[!] $which not accessible or read failed."
    echo "[*] Please remount the device for: $path"
    echo "[*] Press Ctrl-C to abort. The script will resume automatically once the mount is available."
    while true; do
        if check_mount_accessible "$path"; then
            echo "[+] $which is back and accessible. Resuming..."
            return 0
        fi
        sleep 5
        echo "[*] Waiting for $which to be remounted..."
    done
}

# Safe read which appends the next chunk to a .partial file.
# skip_mb and count_mb are integer MB values.
safe_read_chunk_append() {
    local src_file="$1" dst_partial="$2" skip_mb=$3 count_mb=$4

    # Validate source and destination mounts
    if ! check_mount_accessible "$(dirname "$src_file")"; then
        echo "[!] Source appears inaccessible"
        wait_for_mount "$(dirname "$src_file")" "Source"
    fi

    if ! check_mount_accessible "$(dirname "$dst_partial")"; then
        echo "[!] Destination appears inaccessible"
        wait_for_mount "$(dirname "$dst_partial")" "Destination"
    fi

    # Perform the read->append pipeline. Using dd to read from offset and append to partial.
    if ! dd if="$src_file" bs=1M skip=$skip_mb count=$count_mb 2>/dev/null | dd of="$dst_partial" bs=1M oflag=append conv=notrunc 2>/dev/null; then
        return 1
    fi
    return 0
}

get_resume_size_bytes() {
    local f="$1"
    if [ -f "$f.partial" ]; then
        stat -c%s "$f.partial" 2>/dev/null || echo 0
    else
        echo 0
    fi
}

# progressive copy for a single file
progressive_copy_file() {
    local src_file="$1" dst_dir="$2"
    local base
    base=$(basename "$src_file")
    mkdir -p "$dst_dir"

    local file_size
    file_size=$(stat -c%s "$src_file" 2>/dev/null || echo 0)
    if [ "$file_size" -le 0 ]; then
        echo "[!] Skipping empty or inaccessible: $src_file"
        return
    fi

    local copied
    copied=$(get_resume_size_bytes "$dst_dir/$base")

    echo "[*] Progressive copy: '$base' ($(($file_size/1024/1024))MB)"
    if [ $copied -gt 0 ]; then
        echo "[*] Resuming from $((copied*100/file_size))%"
    fi

    # Choose starting chunk
    CHUNK_SIZE=1
    while [ $CHUNK_SIZE -lt $DEFAULT_CHUNK_MB ] && [ $CHUNK_SIZE -lt $((file_size/1024/1024)) ]; do
        CHUNK_SIZE=$((CHUNK_SIZE*2))
    done
    [ $CHUNK_SIZE -gt $DEFAULT_CHUNK_MB ] && CHUNK_SIZE=$DEFAULT_CHUNK_MB

    while [ $copied -lt $file_size ]; do
        local remaining=$((file_size - copied))
        local chunk_bytes=$((CHUNK_SIZE * 1024 * 1024))
        if [ $chunk_bytes -gt $remaining ]; then
            chunk_bytes=$remaining
        fi
        local chunk_mb=$((chunk_bytes/1024/1024))
        local skip_mb=$((copied/1024/1024))

        echo "[*] Reading ${CHUNK_SIZE}MB chunk (offset ${copied} bytes, remaining ${remaining} bytes)"
        if ! safe_read_chunk_append "$src_file" "$dst_dir/$base" $skip_mb $chunk_mb; then
            echo "[!] Read failed or mount lost during chunk read"
            # wait_for_mount will be invoked inside safe_read_chunk_append
            # After mount comes back, shrink chunk size and retry
            echo "[*] Resetting chunk size to 1MB to recover"
            CHUNK_SIZE=1
            continue
        fi

        copied=$(stat -c%s "$dst_dir/$base.partial" 2>/dev/null || echo $copied)
        echo "[*] Progress: $((copied*100/file_size))%"

        # increase chunk size gradually
        if [ $CHUNK_SIZE -lt $DEFAULT_CHUNK_MB ]; then
            CHUNK_SIZE=$((CHUNK_SIZE*2))
            [ $CHUNK_SIZE -gt $DEFAULT_CHUNK_MB ] && CHUNK_SIZE=$DEFAULT_CHUNK_MB
        fi

        sleep $CYCLE_REST
    done

    # Finalize
    mv -f "$dst_dir/$base.partial" "$dst_dir/$base"
    echo "[+] Finished: $dst_dir/$base"
}

progressive_copy_dir() {
    local src_dir="$1" dst_dir="$2"
    mkdir -p "$dst_dir"
    # Preserve ordering
    while IFS= read -r -d $' ' f; do
        rel=${f#"$src_dir"}
        # sanitize leading slash
        rel=${rel#/}
        dest_subdir="$dst_dir/$(dirname "$rel")"
        progressive_copy_file "$f" "$dest_subdir"
    done < <(find "$src_dir" -type f -print0)
}

# parse args
PROBE=false
if [ "${1:-}" = "--help" ] || [ "${1:-}" = "-h" ]; then
    usage; exit 0
fi
if [ "${1:-}" = "--probe" ]; then
    PROBE=true
    shift
fi

if [ $# -ge 2 ]; then
    SRC="$1"
    DEST="$2"
else
    echo "[*] Interactive mode - Please provide the paths:"
    read -rp "Enter source path (file or directory to copy from): " SRC
    read -rp "Enter destination directory: " DEST
fi

# normalize
SRC=$(readlink -f "$SRC" 2>/dev/null || echo "$SRC")
DEST=$(readlink -f "$DEST" 2>/dev/null || echo "$DEST")

# discover mounts and devices
src_info=$(find_mount_source_and_point "$SRC" || true)
dest_info=$(find_mount_source_and_point "$DEST" || true)

src_src=${src_info%%|*}
src_mnt=${src_info##*|}
dest_src=${dest_info%%|*}
dest_mnt=${dest_info##*|}

# Show probe information
echo "[*] Source: $SRC"
echo "[*] Dest: $DEST"
echo "[*] Detected source mount: ${src_src:-(none)} mounted at ${src_mnt:-(none)}"
echo "[*] Detected dest mount: ${dest_src:-(none)} mounted at ${dest_mnt:-(none)}"

if [ -n "$src_src" ]; then
    echo "[*] Source device chain: $(get_device_chain "$src_src")"
fi
if [ -n "$dest_src" ]; then
    echo "[*] Dest device chain: $(get_device_chain "$dest_src")"
fi

if [ "$PROBE" = true ]; then
    echo "[*] Probe mode requested â€” exiting after displaying device info."
    exit 0
fi

# ensure accessibility before copying
if ! check_mount_accessible "$SRC"; then
    echo "[!] Source not accessible. Waiting for you to remount..."
    wait_for_mount "$SRC" "Source"
fi
if ! check_mount_accessible "$DEST"; then
    echo "[!] Destination not accessible. Waiting for you to remount..."
    wait_for_mount "$DEST" "Destination"
fi

echo "[*] Starting progressive copy (1MB->${DEFAULT_CHUNK_MB}MB cycles, ${CYCLE_REST}s rest)"

if [ -f "$SRC" ]; then
    progressive_copy_file "$SRC" "$DEST"
elif [ -d "$SRC" ]; then
    progressive_copy_dir "$SRC" "$DEST"
else
    echo "[!] Source does not exist or is not a regular file/directory: $SRC"
    exit 2
fi

echo "[+] All done."
