#!/bin/bash
# Simple progressive streaming: 1MB->25MB cycles with 3s rest
# Auto-remount and resume capability for BOTH source and destination
# Uses D-Bus to trigger automatic mounting like file managers do
set -euo pipefail

SRC="$1"
DEST="$2"
CHUNK_SIZE=1                   # Start at 1MB
CYCLE_REST=3                   # 3 second rest between cycles

SRC="$(readlink -f "$SRC")"
DEST="$(readlink -f "$DEST")"

if [ ! -e "$SRC" ]; then
    echo "Error: Source '$SRC' does not exist."
    exit 1
fi

mkdir -p "$DEST"
TMPDIR="/dev/shm/memory_copy_$$"
mkdir -p "$TMPDIR"

# Detect device and partition info at startup
echo "[*] Analyzing drive configuration..."
SRC_PARTITION=$(df "$SRC" | tail -1 | awk '{print $1}')
SRC_MOUNTPOINT=$(df "$SRC" | tail -1 | awk '{print $6}')
DEST_PARTITION=$(df "$DEST" | tail -1 | awk '{print $1}')
DEST_MOUNTPOINT=$(df "$DEST" | tail -1 | awk '{print $6}')

# Determine drive types - handle LUKS/encrypted drives
SRC_IS_REMOVABLE=false
DEST_IS_REMOVABLE=false

# For LUKS/mapper devices, find the underlying physical device
get_physical_device() {
    local partition="$1"
    
    if [[ "$partition" =~ ^/dev/mapper/ ]]; then
        # LUKS encrypted device - find the underlying device
        local luks_name=$(basename "$partition")
        if [ -f "/sys/block/dm-*/slaves" ]; then
            for dm_device in /sys/block/dm-*; do
                if [ -d "$dm_device/slaves" ]; then
                    local slave_devices=$(ls "$dm_device/slaves/" 2>/dev/null)
                    if [ -n "$slave_devices" ]; then
                        for slave in $slave_devices; do
                            echo "/dev/$slave"
                            return 0
                        done
                    fi
                fi
            done
        fi
        # Fallback: try to find via lsblk
        local underlying=$(lsblk -no PKNAME "$partition" 2>/dev/null | head -1)
        if [ -n "$underlying" ]; then
            echo "/dev/$underlying"
            return 0
        fi
    fi
    
    # Regular device - strip partition number
    echo "$partition" | sed 's|[0-9]*$||'
}

# Get the underlying physical partition for LUKS devices
get_luks_physical_partition() {
    local mapper_device="$1"
    
    if [[ "$mapper_device" =~ ^/dev/mapper/ ]]; then
        # Find the underlying partition via lsblk
        local underlying=$(lsblk -no PKNAME "$mapper_device" 2>/dev/null | head -1)
        if [ -n "$underlying" ]; then
            echo "/dev/$underlying"
            return 0
        fi
        
        # Alternative method: check /sys/block
        if [ -d "/sys/block/dm-*/slaves" ]; then
            for dm_device in /sys/block/dm-*; do
                if [ -d "$dm_device/slaves" ]; then
                    local slave_devices=$(ls "$dm_device/slaves/" 2>/dev/null)
                    if [ -n "$slave_devices" ]; then
                        for slave in $slave_devices; do
                            echo "/dev/$slave"
                            return 0
                        done
                    fi
                fi
            done
        fi
    fi
    
    # Not a mapper device, return as-is
    echo "$mapper_device"
}

# Store the original physical partitions for LUKS unlocking
SRC_PHYSICAL_PARTITION=""
DEST_PHYSICAL_PARTITION=""

if [[ "$SRC_PARTITION" =~ ^/dev/mapper/ ]]; then
    SRC_PHYSICAL_PARTITION=$(get_luks_physical_partition "$SRC_PARTITION")
    echo "[*] Source LUKS mapper: $SRC_PARTITION -> physical: $SRC_PHYSICAL_PARTITION"
else
    SRC_PHYSICAL_PARTITION="$SRC_PARTITION"
fi

if [[ "$DEST_PARTITION" =~ ^/dev/mapper/ ]]; then
    DEST_PHYSICAL_PARTITION=$(get_luks_physical_partition "$DEST_PARTITION")
    echo "[*] Destination LUKS mapper: $DEST_PARTITION -> physical: $DEST_PHYSICAL_PARTITION"
else
    DEST_PHYSICAL_PARTITION="$DEST_PARTITION"
fi

# Get physical devices for removable detection
SRC_PHYSICAL=$(get_physical_device "$SRC_PARTITION")
DEST_PHYSICAL=$(get_physical_device "$DEST_PARTITION")

SRC_DEV_BASE=$(basename "$SRC_PHYSICAL")
DEST_DEV_BASE=$(basename "$DEST_PHYSICAL")

# Check if source is removable/USB (check the physical device)
if [ -f "/sys/block/$SRC_DEV_BASE/removable" ]; then
    if [ "$(cat /sys/block/$SRC_DEV_BASE/removable)" = "1" ]; then
        SRC_IS_REMOVABLE=true
    fi
fi

# Check if destination is removable/USB  
if [ -f "/sys/block/$DEST_DEV_BASE/removable" ]; then
    if [ "$(cat /sys/block/$DEST_DEV_BASE/removable)" = "1" ]; then
        DEST_IS_REMOVABLE=true
    fi
fi

echo "[*] Source: $SRC ($SRC_PARTITION -> $SRC_PHYSICAL) - $([ "$SRC_IS_REMOVABLE" = true ] && echo "USB/Removable" || echo "Fixed Drive")"
echo "[*] Destination: $DEST ($DEST_PARTITION -> $DEST_PHYSICAL) - $([ "$DEST_IS_REMOVABLE" = true ] && echo "USB/Removable" || echo "Fixed Drive")"

# Warn if destination is also removable
if [ "$DEST_IS_REMOVABLE" = true ]; then
    echo "[!] WARNING: Destination is also on removable media!"
fi

# Check if drive is mounted and accessible (generic version for both src/dest)
check_drive_status() {
    local path="$1"
    local drive_name="$2"
    
    if [ ! -e "$path" ]; then
        echo "[!] $drive_name path not accessible: $path"
        return 1  # Drive unmounted
    fi
    
    # Try a simple read test for source, write test for destination
    if [ "$drive_name" = "Source" ]; then
        dd if="$path" of=/dev/null bs=1024 count=1 2>/dev/null || {
            echo "[!] $drive_name read test failed"
            return 1
        }
    else
        # For destination, check if we can write (create a small test file)
        local test_file="$path/.write_test_$$"
        if ! echo "test" > "$test_file" 2>/dev/null; then
            echo "[!] $drive_name write test failed"
            return 1
        fi
        rm -f "$test_file" 2>/dev/null
    fi
    return 0
}

# Function to trigger D-Bus device scanning (like when you plug in a drive)
trigger_device_scan() {
    echo "[*] Triggering device scan via udev..."
    
    # Trigger udev to rescan the device
    if command -v udevadm >/dev/null 2>&1; then
        udevadm trigger --subsystem-match=block 2>/dev/null || true
        udevadm settle 2>/dev/null || true
        sleep 2
    fi
    
    # Also try to trigger udisks2 to rescan
    if command -v gdbus >/dev/null 2>&1; then
        echo "[*] Asking udisks2 daemon to rescan devices..."
        # This is what file managers do - ask udisks2 to check for new devices
        gdbus call --system --dest org.freedesktop.UDisks2 \
            --object-path /org/freedesktop/UDisks2/Manager \
            --method org.freedesktop.UDisks2.Manager.GetBlockDevices \
            '{}' >/dev/null 2>&1 || true
    fi
}

# Function to wait for device to appear in udisks2
wait_for_udisks_device() {
    local device="$1"
    local timeout=30
    local count=0
    
    echo "[*] Waiting for device to appear in udisks2: $device"
    
    while [ $count -lt $timeout ]; do
        if command -v gdbus >/dev/null 2>&1; then
            # Check if udisks2 knows about our device
            local device_path="/org/freedesktop/UDisks2/block_devices/$(basename "$device" | sed 's|/|_|g')"
            if gdbus introspect --system --dest org.freedesktop.UDisks2 --object-path "$device_path" >/dev/null 2>&1; then
                echo "[+] Device found in udisks2: $device_path"
                return 0
            fi
        fi
        
        sleep 1
        count=$((count + 1))
    done
    
    echo "[!] Device not found in udisks2 after ${timeout}s"
    return 1
}

# Non-interactive mounting using desktop environment methods (like Thunar does)
remount_drive_system() {
    local physical_partition="$1"
    local drive_name="$2"
    
    echo "[!] Attempting to remount $drive_name drive using desktop methods..."
    echo "[*] Physical partition: $physical_partition"
    
    # First, trigger device scanning
    trigger_device_scan
    
    # Method 0: Try to notify the desktop environment about the device
    if [ -n "$DISPLAY" ] && [ -n "$USER" ]; then
        echo "[*] Attempting desktop environment notification..."
        
        # Try to trigger a desktop notification about the new device
        # This simulates what happens when you plug in a drive
        if command -v notify-send >/dev/null 2>&1; then
            notify-send "Drive Reconnection" "Attempting to remount $drive_name drive..." --icon=drive-removable-media 2>/dev/null || true
        fi
        
        # Try to use gvfs-mount (what desktop environments often use)
        if command -v gvfs-mount >/dev/null 2>&1; then
            echo "[*] Trying gvfs-mount (desktop environment method)..."
            if gvfs-mount -d "$physical_partition" 2>/dev/null; then
                echo "[+] Successfully mounted via gvfs-mount"
                sleep 3
                
                local new_mountpoint=$(findmnt -n -o TARGET "$physical_partition" 2>/dev/null)
                if [ -z "$new_mountpoint" ]; then
                    # For LUKS, check mapper devices
                    local mapper_devices=$(ls /dev/mapper/ 2>/dev/null | grep -v control)
                    for mapper in $mapper_devices; do
                        local full_mapper="/dev/mapper/$mapper"
                        if new_mountpoint=$(findmnt -n -o TARGET "$full_mapper" 2>/dev/null); then
                            if [[ "$new_mountpoint" =~ ^/run/media/ ]] || [[ "$new_mountpoint" =~ ^/media/ ]]; then
                                physical_partition="$full_mapper"
                                break
                            fi
                        fi
                    done
                fi
                
                if [ -n "$new_mountpoint" ]; then
                    update_drive_paths "$drive_name" "$physical_partition" "$new_mountpoint"
                    return 0
                fi
            fi
        fi
        
        # Try to open the file manager to the device (this often triggers auto-mount)
        if command -v thunar >/dev/null 2>&1; then
            echo "[*] Attempting to trigger Thunar to recognize device..."
            # Open thunar to computer:// which shows drives and may trigger recognition
            thunar computer:// 2>/dev/null &
            local thunar_pid=$!
            sleep 3
            kill $thunar_pid 2>/dev/null || true
            
            # Check if this triggered a mount
            local new_mountpoint=$(findmnt -n -o TARGET "$physical_partition" 2>/dev/null)
            if [ -n "$new_mountpoint" ]; then
                echo "[+] Thunar triggered successful mount"
                update_drive_paths "$drive_name" "$physical_partition" "$new_mountpoint"
                return 0
            fi
        fi
    else
        echo "[*] No desktop environment detected (no DISPLAY or USER)"
    fi
    
    # Method 2: Try dmsetup for LUKS devices (what we saw in bpftrace)
    if [[ "$SRC_PARTITION" =~ ^/dev/mapper/ ]] || [[ "$DEST_PARTITION" =~ ^/dev/mapper/ ]]; then
        if command -v dmsetup >/dev/null 2>&1; then
            echo "[*] Trying dmsetup for LUKS device..."
            
            # Check if there are any inactive mapper devices that could be our drive
            local inactive_mappers=$(dmsetup info -c --noheadings -o name,attr 2>/dev/null | grep "^luks-" | awk '{print $1}')
            for mapper_name in $inactive_mappers; do
                local full_mapper="/dev/mapper/$mapper_name"
                
                # Try to activate/resume the mapper device
                if dmsetup resume "$mapper_name" 2>/dev/null; then
                    echo "[+] Successfully resumed dmsetup device: $mapper_name"
                    
                    # Now try to mount it
                    if command -v udisksctl >/dev/null 2>&1; then
                        if udisksctl mount -b "$full_mapper" 2>/dev/null; then
                            echo "[+] Successfully mounted resumed mapper device"
                            local new_mountpoint=$(findmnt -n -o TARGET "$full_mapper" 2>/dev/null)
                            if [ -n "$new_mountpoint" ]; then
                                update_drive_paths "$drive_name" "$full_mapper" "$new_mountpoint"
                                return 0
                            fi
                        fi
                    fi
                fi
            done
        fi
    fi
    if command -v pmount >/dev/null 2>&1; then
        echo "[*] Trying pmount for removable device..."
        local mount_label=$(basename "$physical_partition")
        if pmount "$physical_partition" "$mount_label" 2>/dev/null; then
            echo "[+] Successfully mounted via pmount"
            local new_mountpoint="/media/$mount_label"
            if [ -d "$new_mountpoint" ]; then
                update_drive_paths "$drive_name" "$physical_partition" "$new_mountpoint"
                return 0
            fi
        fi
    fi
    
    # Method 3: Try pmount (if available) - designed for removable media
    echo "[*] Checking if device auto-mounted..."
    sleep 3  # Give time for auto-mount
    
    # Look for any new mounts in /run/media or /media
    local possible_mounts=$(mount | grep -E "^${physical_partition}|^/dev/mapper/" | awk '{print $3}' || true)
    for mountpoint in $possible_mounts; do
        if [[ "$mountpoint" =~ ^/run/media/ ]] || [[ "$mountpoint" =~ ^/media/ ]]; then
            local mounted_device=$(mount | grep " $mountpoint " | awk '{print $1}' | head -1)
            echo "[+] Found auto-mounted device: $mounted_device at $mountpoint"
            update_drive_paths "$drive_name" "$mounted_device" "$mountpoint"
            return 0
        fi
    done
    
    # Method 4: Check if it auto-mounted after device scan
    if command -v dbus-send >/dev/null 2>&1; then
        echo "[*] Trying to trigger udisks2 mount via D-Bus..."
        # Get the udisks2 object path for our device
        local device_name=$(basename "$physical_partition")
        local device_path="/org/freedesktop/UDisks2/block_devices/${device_name}"
        
        # Try to call the Mount method on the filesystem interface
        if dbus-send --system --print-reply \
            --dest=org.freedesktop.UDisks2 \
            "${device_path}" \
            org.freedesktop.UDisks2.Filesystem.Mount \
            'dict:string:variant:' 2>/dev/null; then
            echo "[+] Successfully triggered udisks2 mount"
            sleep 3
            local new_mountpoint=$(findmnt -n -o TARGET "$physical_partition" 2>/dev/null)
            if [ -n "$new_mountpoint" ]; then
                update_drive_paths "$drive_name" "$physical_partition" "$new_mountpoint"
                return 0
            fi
        fi
    fi
    
    # Method 4: Try udisks --mount (older udisks1 compatibility)
    if command -v udisks >/dev/null 2>&1; then
        echo "[*] Trying legacy udisks mount..."
        if udisks --mount "$physical_partition" 2>/dev/null; then
            echo "[+] Successfully mounted via udisks (v1)"
            local new_mountpoint=$(findmnt -n -o TARGET "$physical_partition" 2>/dev/null)
            if [ -n "$new_mountpoint" ]; then
                update_drive_paths "$drive_name" "$physical_partition" "$new_mountpoint"
                return 0
            fi
        fi
    fi
    
    # Method 5: Try manual mount to /mnt (last resort)
    echo "[*] Trying manual mount to /mnt..."
    local temp_mountpoint="/mnt/temp_$(basename "$physical_partition")_$$"
    if mkdir -p "$temp_mountpoint" 2>/dev/null; then
        if mount "$physical_partition" "$temp_mountpoint" 2>/dev/null; then
            echo "[+] Successfully mounted to temporary location: $temp_mountpoint"
            update_drive_paths "$drive_name" "$physical_partition" "$temp_mountpoint"
            return 0
        fi
        rmdir "$temp_mountpoint" 2>/dev/null || true
    fi
    
    echo "[!] All mounting attempts failed"
    return 1
}

# Update drive paths after successful remount
update_drive_paths() {
    local drive_name="$1"
    local new_partition="$2"
    local new_mountpoint="$3"
    
    echo "[*] Updating $drive_name paths..."
    echo "[*] New partition: $new_partition"
    echo "[*] New mountpoint: $new_mountpoint"
    
    if [ "$drive_name" = "Source" ]; then
        # Update source variables and path
        local old_mount_escaped=$(echo "$SRC_MOUNTPOINT" | sed 's|/|\\/|g')
        local new_mount_escaped=$(echo "$new_mountpoint" | sed 's|/|\\/|g')
        SRC_PARTITION="$new_partition"
        SRC_MOUNTPOINT="$new_mountpoint"
        SRC=$(echo "$SRC" | sed "s|$old_mount_escaped|$new_mount_escaped|")
        echo "[*] Updated source path: $SRC"
    else
        # Update destination variables and path
        local old_mount_escaped=$(echo "$DEST_MOUNTPOINT" | sed 's|/|\\/|g')
        local new_mount_escaped=$(echo "$new_mountpoint" | sed 's|/|\\/|g')
        DEST_PARTITION="$new_partition"
        DEST_MOUNTPOINT="$new_mountpoint"
        DEST=$(echo "$DEST" | sed "s|$old_mount_escaped|$new_mount_escaped|")
        echo "[*] Updated destination path: $DEST"
    fi
}

# Wait for drive with non-interactive remounting
wait_for_drive() {
    local path="$1"
    local partition="$2" 
    local mountpoint="$3"
    local drive_name="$4"
    local is_removable="$5"
    local physical_partition="$6"
    
    echo "[!] $drive_name drive not accessible"
    echo "[*] Attempting automatic remount (non-interactive)..."
    
    # Try non-interactive system mounting
    local attempt=1
    while [ $attempt -le 3 ]; do
        echo "[*] System mount attempt $attempt/3 for $drive_name..."
        
        if remount_drive_system "$physical_partition" "$drive_name"; then
            # Give it a moment to settle
            sleep 3
            if check_drive_status "$path" "$drive_name"; then
                echo "[+] Successfully remounted and verified $drive_name drive"
                return 0
            else
                echo "[*] Mount succeeded but original path not accessible"
                echo "[*] This is normal - checking if file exists in new location..."
                
                # For source drives, try to find the file in the new mount location
                if [ "$drive_name" = "Source" ]; then
                    local basename_file=$(basename "$path")
                    local dirname_file=$(dirname "$path")
                    local relative_path=${dirname_file#$mountpoint}
                    local new_file_path="$SRC_MOUNTPOINT$relative_path/$basename_file"
                    
                    if [ -e "$new_file_path" ]; then
                        echo "[+] Found file in new location: $new_file_path"
                        SRC="$new_file_path"
                        return 0
                    fi
                fi
                
                # For destination drives, just update the directory
                if [ "$drive_name" = "Destination" ]; then
                    local relative_path=${path#$mountpoint}
                    local new_dest_path="$DEST_MOUNTPOINT$relative_path"
                    echo "[*] Updated destination to: $new_dest_path"
                    DEST="$new_dest_path"
                    mkdir -p "$DEST" 2>/dev/null || true
                    return 0
                fi
            fi
        fi
        
        echo "[*] Waiting 10 seconds before next attempt..."
        sleep 10
        attempt=$((attempt + 1))
    done
    
    # If automatic failed, give advice
    if [[ "$partition" =~ ^/dev/mapper/ ]]; then
        echo "[!] Automatic LUKS mount failed for $drive_name drive"
        echo "[*] LUKS encrypted drives may need manual unlocking"
        echo "[*] The drive was previously unlocked, but the encryption session expired"
    elif [ "$is_removable" = true ]; then
        echo "[!] Automatic remount failed for removable $drive_name drive"
        echo "[*] Please check USB connection or try reconnecting the drive"
    else
        echo "[!] Automatic remount failed for fixed $drive_name drive"
        echo "[*] Please check drive connection"
    fi
    
    echo "[*] Manual options for $drive_name:"
    echo "[*] 1. Click drive icon in file manager (Thunar) to unlock/mount"
    echo "[*] 2. Reconnect the USB drive if it's removable"
    if [[ "$partition" =~ ^/dev/mapper/ ]]; then
        echo "[*] 3. For encrypted drives, you may need to re-enter the password"
    fi
    
    # Continue checking every 15 seconds (longer for manual intervention)
    while true; do
        if check_drive_status "$path" "$drive_name"; then
            echo "[+] $drive_name drive is accessible again"
            return 0
        fi
        echo "[*] Still waiting for $drive_name drive access... (checking every 15 seconds)"
        echo "[*] Please use file manager to unlock/mount the drive"
        sleep 15
    done
}

# Next chunk size in 1-25MB cycle
next_chunk_size() {
    CHUNK_SIZE=$((CHUNK_SIZE + 1))
    if [ $CHUNK_SIZE -gt 25 ]; then
        echo "[*] Cycle complete, resting ${CYCLE_REST}s..."
        sleep $CYCLE_REST
        CHUNK_SIZE=1
        echo "[*] New cycle: 1MB->25MB"
    fi
}

# Safe read with drive monitoring
safe_read() {
    local file="$1"
    local output="$2"
    local skip_mb="$3"
    local count_mb="$4"
    
    # Check source drive before read
    if ! check_drive_status "$SRC" "Source"; then
        echo "[!] Source drive unmounted during operation!"
        wait_for_drive "$SRC" "$SRC_PARTITION" "$SRC_MOUNTPOINT" "Source" "$SRC_IS_REMOVABLE" "$SRC_PHYSICAL_PARTITION"
        echo "[*] Resetting to 1MB chunk size after reconnect"
        CHUNK_SIZE=1
        # Update file path in case it changed
        file="$SRC"
    fi
    
    # Perform the read
    if dd if="$file" of="$output" bs=1M count=$count_mb skip=$skip_mb 2>/dev/null; then
        return 0
    else
        # Read failed - check if drive is still there
        if ! check_drive_status "$SRC" "Source"; then
            echo "[!] Source drive unmounted during read!"
            wait_for_drive "$SRC" "$SRC_PARTITION" "$SRC_MOUNTPOINT" "Source" "$SRC_IS_REMOVABLE" "$SRC_PHYSICAL_PARTITION"
            echo "[*] Resetting to 1MB chunk size after reconnect"
            CHUNK_SIZE=1
            return 1
        fi
        
        # Drive is there but read failed
        echo "[!] Read failed, source drive still connected"
        return 1
    fi
}

# Safe write with destination drive monitoring
safe_write() {
    local input="$1"
    local dest_file="$2"
    
    # Check destination drive before write
    if ! check_drive_status "$DEST" "Destination"; then
        echo "[!] Destination drive unmounted during operation!"
        wait_for_drive "$DEST" "$DEST_PARTITION" "$DEST_MOUNTPOINT" "Destination" "$DEST_IS_REMOVABLE" "$DEST_PHYSICAL_PARTITION"
        echo "[*] Resetting to 1MB chunk size after reconnect"
        CHUNK_SIZE=1
        # Update dest_file path in case DEST changed
        local basename_file=$(basename "$dest_file")
        dest_file="$DEST/$basename_file"
    fi
    
    # Ensure destination directory exists
    mkdir -p "$(dirname "$dest_file")" 2>/dev/null || true
    
    # Perform the write
    if cat "$input" >> "$dest_file"; then
        return 0
    else
        # Write failed - check if destination drive is still there
        if ! check_drive_status "$DEST" "Destination"; then
            echo "[!] Destination drive unmounted during write!"
            wait_for_drive "$DEST" "$DEST_PARTITION" "$DEST_MOUNTPOINT" "Destination" "$DEST_IS_REMOVABLE" "$DEST_PHYSICAL_PARTITION"
            echo "[*] Resetting to 1MB chunk size after reconnect"
            CHUNK_SIZE=1
            return 1
        fi
        
        # Drive is there but write failed
        echo "[!] Write failed, destination drive still connected"
        return 1
    fi
}

# Check if file was partially copied and resume
get_resume_position() {
    local dest_file="$1"
    
    if [ -f "$dest_file.partial" ]; then
        local partial_size=$(stat -c%s "$dest_file.partial" 2>/dev/null || echo 0)
        echo "[*] Found partial file, resuming from $((partial_size/1024/1024))MB"
        echo $partial_size
    else
        echo 0
    fi
}

# Progressive copy function
progressive_copy_file() {
    local file="$1"
    local dest="$2"
    local base="$(basename "$file")"
    local file_size=$(stat -c%s "$file" 2>/dev/null || echo 0)
    local copied=$(get_resume_position "$dest/$base")
    
    echo "[*] Progressive copy: '$base' ($(($file_size/1024/1024))MB)"
    
    mkdir -p "$dest"
    
    # If resuming, show current progress
    if [ $copied -gt 0 ]; then
        echo "[*] Resuming from $(($copied*100/$file_size))% complete"
    fi
    
    while [ $copied -lt $file_size ]; do
        local chunk_bytes=$((CHUNK_SIZE * 1024 * 1024))
        local remaining=$((file_size - copied))
        
        # Don't read more than what's left
        [ $chunk_bytes -gt $remaining ] && chunk_bytes=$remaining
        
        echo "[*] Reading ${CHUNK_SIZE}MB chunk..."
        
        # Safe read with drive monitoring
        if safe_read "$file" "$TMPDIR/${base}.chunk" $((copied/1024/1024)) $CHUNK_SIZE; then
            # Safe write to destination with drive monitoring
            if safe_write "$TMPDIR/${base}.chunk" "$dest/$base.partial"; then
                rm -f "$TMPDIR/${base}.chunk"
                copied=$((copied + chunk_bytes))
                echo "[*] Progress: $(($copied*100/$file_size))%"
                
                next_chunk_size
            else
                echo "[!] Write chunk failed, retrying..."
                rm -f "$TMPDIR/${base}.chunk" 2>/dev/null
                sleep 1
                continue
            fi
        else
            echo "[!] Read chunk failed, retrying..."
            sleep 1
            continue
        fi
    done
    
    # Finalize file
    mv "$dest/$base.partial" "$dest/$base"
    echo "[+] Completed: $base"
}

# Progressive directory copy
progressive_copy_dir() {
    local dir="$1"
    local dest="$2"
    
    find "$dir" -type f | while read -r f; do
        rel_path="${f#$dir/}"
        dest_dir="$dest/$(dirname "$rel_path")"
        progressive_copy_file "$f" "$dest_dir"
    done
}

echo "[*] Starting progressive copy (1MB->25MB cycles, ${CYCLE_REST}s rest)"
echo "[*] Source: $SRC"
echo "[*] Dest: $DEST"
echo "[*] Source device: $SRC_PARTITION mounted at $SRC_MOUNTPOINT"
echo "[*] Destination device: $DEST_PARTITION mounted at $DEST_MOUNTPOINT"

if [ -f "$SRC" ]; then
    progressive_copy_file "$SRC" "$DEST"
elif [ -d "$SRC" ]; then
    progressive_copy_dir "$SRC" "$DEST"
fi

rm -rf "$TMPDIR"
echo "[+] Progressive copy complete: $DEST"
